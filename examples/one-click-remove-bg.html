<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="author" content="钱猎献" />
    <title>一键抠图</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #f5f7fb;
        --bg-dark: #1f2933;
        --card: rgba(255, 255, 255, 0.9);
        --card-dark: rgba(31, 41, 51, 0.9);
        --primary: #4f46e5;
        --text: #1f2933;
        --text-dark: #e5e7eb;
        --muted: #6b7280;
      }

      body {
        margin: 0;
        font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
        background: linear-gradient(160deg, var(--bg), #dbeafe);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background: linear-gradient(160deg, var(--bg-dark), #111827);
          color: var(--text-dark);
        }
      }

      header {
        max-width: 960px;
        padding: 64px 24px 24px;
        text-align: center;
      }

      h1 {
        font-size: 3rem;
        margin-bottom: 16px;
        letter-spacing: 0.08em;
      }

      p.subtitle {
        font-size: 1.15rem;
        color: var(--muted);
        margin: 0 auto 32px;
        max-width: 520px;
      }

      .config-note {
        margin: -8px auto 24px;
        font-size: 0.9rem;
        max-width: 640px;
        color: var(--muted);
      }

      .config-note code {
        font-family: "SFMono-Regular", "Consolas", "Liberation Mono", Menlo, monospace;
        background: rgba(148, 163, 184, 0.18);
        padding: 2px 6px;
        border-radius: 6px;
      }

      .model-selector {
        margin: 0 auto 32px;
        padding: 16px 20px;
        border-radius: 18px;
        background: var(--card);
        box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        display: inline-flex;
        align-items: center;
        gap: 16px;
      }

      @media (prefers-color-scheme: dark) {
        .model-selector {
          background: var(--card-dark);
          box-shadow: 0 12px 32px rgba(17, 24, 39, 0.6);
          color: var(--text-dark);
        }
      }

      .model-selector .current-model-label {
        font-weight: 600;
      }

      .model-selector button {
        padding: 8px 18px;
        background: var(--primary);
        color: #fff;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .model-selector button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
      }

      .hidden {
        display: none !important;
      }

      .advanced-guard {
        width: min(90vw, 720px);
        margin: 0 auto 32px;
        padding: 24px;
        border-radius: 20px;
        background: var(--card);
        box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 16px;
        color: var(--text);
      }

      .advanced-guard__title {
        font-size: 1.1rem;
        font-weight: 600;
        margin: 0;
      }

      .advanced-guard__warning {
        margin: 0;
        color: #dc2626;
        font-size: 0.95rem;
        line-height: 1.5;
      }

      .advanced-guard__form {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      .advanced-guard__input {
        flex: 1 1 160px;
        min-width: 160px;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        font-size: 1rem;
        background: rgba(255, 255, 255, 0.85);
        color: inherit;
      }

      .advanced-guard__button {
        padding: 10px 20px;
        border-radius: 999px;
        border: none;
        background: var(--primary);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .advanced-guard__button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(79, 70, 229, 0.3);
      }

      .advanced-guard__feedback {
        min-height: 1.2em;
        font-size: 0.9rem;
        color: #ef4444;
      }

      @media (prefers-color-scheme: dark) {
        .advanced-guard {
          background: var(--card-dark);
          box-shadow: 0 12px 32px rgba(17, 24, 39, 0.6);
          color: var(--text-dark);
        }

        .advanced-guard__input {
          background: rgba(17, 24, 39, 0.6);
          border-color: rgba(148, 163, 184, 0.4);
        }
      }

      .control-panel {
        width: min(90vw, 720px);
        margin: 0 auto 32px;
        padding: 24px;
        border-radius: 20px;
        background: var(--card);
        box-shadow: 0 12px 32px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      @media (prefers-color-scheme: dark) {
        .control-panel {
          background: var(--card-dark);
          box-shadow: 0 12px 32px rgba(17, 24, 39, 0.6);
          color: var(--text-dark);
        }
      }

      .control-panel__header {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .control-panel__title {
        font-size: 1.2rem;
        font-weight: 600;
        margin: 0;
      }

      .control-panel__subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .control-panel__toggles {
        display: flex;
        flex-direction: column;
        gap: 18px;
      }

      .toggle-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 24px;
        flex-wrap: wrap;
      }

      .toggle-text {
        flex: 1;
        min-width: 220px;
      }

      .toggle-label {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .toggle-hint {
        margin: 0;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .switch {
        position: relative;
        display: inline-block;
        width: 48px;
        height: 26px;
      }

      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .switch-slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background: rgba(107, 114, 128, 0.4);
        border-radius: 999px;
        transition: background 0.2s ease;
      }

      .switch-slider::before {
        content: "";
        position: absolute;
        height: 20px;
        width: 20px;
        left: 3px;
        bottom: 3px;
        background: #fff;
        border-radius: 50%;
        transition: transform 0.2s ease;
        box-shadow: 0 6px 16px rgba(15, 23, 42, 0.2);
      }

      .switch input:checked + .switch-slider {
        background: var(--primary);
      }

      .switch input:checked + .switch-slider::before {
        transform: translateX(22px);
      }

      @media (prefers-color-scheme: dark) {
        .switch-slider::before {
          background: #1f2937;
          box-shadow: 0 6px 16px rgba(15, 23, 42, 0.5);
        }
      }

      .control-panel__body {
        display: grid;
        gap: 18px;
      }

      @media (min-width: 640px) {
        .control-panel__body {
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }
      }

      .slider-control {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 14px;
        border-radius: 16px;
        background: rgba(99, 102, 241, 0.06);
        transition: opacity 0.2s ease, background 0.2s ease;
      }

      .slider-control.inactive {
        opacity: 0.6;
      }

      @media (prefers-color-scheme: dark) {
        .slider-control {
          background: rgba(129, 140, 248, 0.18);
        }
      }

      .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
      }

      .slider-value {
        font-variant-numeric: tabular-nums;
        color: var(--primary);
      }

      .slider-control input[type="range"] {
        width: 100%;
        accent-color: var(--primary);
      }

      .slider-hint {
        margin: 0;
        font-size: 0.8rem;
        color: var(--muted);
        line-height: 1.4;
      }

      .drop-area {
        width: min(90vw, 640px);
        min-height: 240px;
        border: 2px dashed rgba(79, 70, 229, 0.4);
        border-radius: 24px;
        padding: 48px 24px;
        background: var(--card);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 16px;
        transition: transform 0.3s ease, border-color 0.3s ease,
          box-shadow 0.3s ease;
        cursor: pointer;
      }

      @media (prefers-color-scheme: dark) {
        .drop-area {
          background: var(--card-dark);
          border-color: rgba(129, 140, 248, 0.4);
        }
      }

      .drop-area.dragover {
        transform: translateY(-6px);
        border-color: rgba(79, 70, 229, 0.8);
        box-shadow: 0 18px 40px rgba(79, 70, 229, 0.2);
      }

      .drop-area svg {
        width: 64px;
        height: 64px;
        fill: var(--primary);
      }

      .drop-area .hint {
        font-size: 1.05rem;
        font-weight: 600;
      }

      .drop-area .tip {
        color: var(--muted);
        font-size: 0.95rem;
      }

      input[type="file"] {
        display: none;
      }

      .task-list {
        margin: 40px 0 80px;
        width: min(90vw, 720px);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .task-item {
        background: var(--card);
        border-radius: 20px;
        padding: 20px 24px;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      @media (prefers-color-scheme: dark) {
        .task-item {
          background: var(--card-dark);
          box-shadow: 0 10px 30px rgba(17, 24, 39, 0.6);
        }
      }

      .format-toggle {
        display: inline-flex;
        align-self: flex-end;
        gap: 6px;
        padding: 6px;
        border-radius: 999px;
        background: rgba(99, 102, 241, 0.08);
        transition: background 0.2s ease;
      }

      .format-toggle.hidden {
        display: none;
      }

      .format-toggle__option {
        border: none;
        border-radius: 999px;
        padding: 6px 18px;
        font-weight: 600;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
      }

      .format-toggle__option[aria-pressed="true"] {
        background: #fff;
        color: var(--primary);
        transform: translateY(-1px);
        box-shadow: 0 8px 18px rgba(99, 102, 241, 0.25);
      }

      .format-toggle__option--unavailable,
      .format-toggle__option:disabled {
        cursor: not-allowed;
        opacity: 0.5;
        box-shadow: none;
        transform: none;
      }

      @media (prefers-color-scheme: dark) {
        .format-toggle {
          background: rgba(129, 140, 248, 0.18);
        }

        .format-toggle__option[aria-pressed="true"] {
          background: rgba(17, 24, 39, 0.9);
          color: #cbd5f5;
          box-shadow: 0 8px 18px rgba(129, 140, 248, 0.3);
        }
      }

      .task-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 16px;
        flex-wrap: wrap;
      }

      .task-name {
        font-weight: 600;
        word-break: break-all;
      }

      .task-status {
        font-size: 0.9rem;
        color: var(--muted);
      }

      .progress-bar {
        width: 100%;
        height: 10px;
        border-radius: 999px;
        background: rgba(99, 102, 241, 0.1);
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, #6366f1, #8b5cf6);
        transition: width 0.2s ease;
      }

      .download-link {
        align-self: flex-end;
        background: var(--primary);
        color: #fff;
        text-decoration: none;
        padding: 8px 16px;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease, transform 0.2s ease;
      }

      .download-link.visible {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0);
      }

      .model-dialog {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(15, 23, 42, 0.45);
        backdrop-filter: blur(6px);
        padding: 24px;
        z-index: 100;
      }

      .model-dialog.visible {
        display: flex;
      }

      .model-dialog__card {
        width: min(640px, 90vw);
        max-height: min(520px, 90vh);
        overflow: hidden;
        border-radius: 24px;
        background: var(--card);
        box-shadow: 0 24px 60px rgba(15, 23, 42, 0.25);
        display: flex;
        flex-direction: column;
      }

      @media (prefers-color-scheme: dark) {
        .model-dialog__card {
          background: var(--card-dark);
          box-shadow: 0 24px 60px rgba(0, 0, 0, 0.6);
        }
      }

      .model-dialog__header {
        padding: 24px 28px 0;
        text-align: left;
      }

      .model-dialog__body {
        padding: 16px 28px 0;
        overflow-y: auto;
      }

      .model-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
      }

      .model-card {
        position: relative;
        border: 1px solid rgba(99, 102, 241, 0.12);
        border-radius: 18px;
        padding: 18px;
        text-align: left;
        cursor: pointer;
        transition: transform 0.2s ease, border-color 0.2s ease,
          box-shadow 0.2s ease;
        background: rgba(255, 255, 255, 0.6);
      }

      @media (prefers-color-scheme: dark) {
        .model-card {
          background: rgba(31, 41, 55, 0.6);
          border-color: rgba(129, 140, 248, 0.12);
          color: var(--text-dark);
        }
      }

      .model-card:hover,
      .model-card[data-selected="true"] {
        transform: translateY(-3px);
        border-color: rgba(79, 70, 229, 0.6);
        box-shadow: 0 16px 32px rgba(79, 70, 229, 0.18);
      }

      .model-card__name {
        font-weight: 700;
        margin-bottom: 8px;
      }

      .model-card__desc {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .model-card__tooltip {
        position: absolute;
        inset: auto 12px 12px 12px;
        border-radius: 12px;
        background: rgba(30, 64, 175, 0.08);
        padding: 8px 10px;
        font-size: 0.75rem;
        color: var(--primary);
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }

      .model-card:hover .model-card__tooltip {
        opacity: 1;
      }

      .model-dialog__actions {
        padding: 18px 28px 28px;
        display: flex;
        justify-content: flex-end;
        gap: 12px;
        background: linear-gradient(
          to top,
          rgba(15, 23, 42, 0.08),
          rgba(15, 23, 42, 0)
        );
      }

      .model-dialog__actions button {
        padding: 10px 20px;
        border-radius: 999px;
        border: none;
        font-weight: 600;
        cursor: pointer;
      }

      .model-dialog__actions .cancel-btn {
        background: rgba(107, 114, 128, 0.16);
        color: var(--text);
      }

      @media (prefers-color-scheme: dark) {
        .model-dialog__actions .cancel-btn {
          color: var(--text-dark);
          background: rgba(148, 163, 184, 0.22);
        }
      }

      .model-dialog__actions .confirm-btn {
        background: var(--primary);
        color: #fff;
        box-shadow: 0 10px 24px rgba(79, 70, 229, 0.24);
      }

      footer {
        margin: auto 0 24px;
        color: var(--muted);
        font-size: 0.85rem;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>一键抠图</h1>
      <p class="subtitle">
        将图片拖入页面任意位置，即可自动上传到抠图服务并返回透明背景图片。
        支持批量拖拽，处理完成后自动下载结果。
      </p>
      <p class="config-note">
        默认使用 BRIA RMBG v2 模型
        ----仅限准许情况下使用----可通过下方高级参数微调 Alpha 抠图阈值
        与遮罩后处理，实时数值显示便于复制服务端配置---仅限准许情况下使用----
      </p>

      <section class="advanced-guard" id="advanced-guard" aria-live="polite">
        <h2 class="advanced-guard__title">技术部调试用高级参数（默认隐藏）</h2>
        <p class="advanced-guard__warning">
          ⚠️ 仅限技术部调试使用，错误设置可能导致抠图结果异常，甚至让服务任务卡死。
          不懂的同事请勿尝试开启。
        </p>
        <div class="advanced-guard__form">
          <label for="advanced-password">调试口令：</label>
          <input
            type="password"
            id="advanced-password"
            class="advanced-guard__input"
            placeholder="输入调试口令"
            autocomplete="off"
          />
          <button type="button" class="advanced-guard__button" id="unlock-advanced">
            输入口令开启
          </button>
        </div>
        <div class="advanced-guard__feedback" id="advanced-feedback" role="status"></div>
      </section>

      <section
        class="control-panel hidden"
        id="advanced-control-panel"
        aria-labelledby="control-panel-title"
        aria-hidden="true"
      >
        <div class="control-panel__header">
          <h2 class="control-panel__title" id="control-panel-title">高级参数</h2>
          <p class="control-panel__subtitle">
            启用 Alpha 抠图可针对发丝、透明物体进行精细保留，滑块提供实时数值显示。
          </p>
        </div>

        <div class="control-panel__toggles">
          <div class="toggle-row">
            <div class="toggle-text">
              <div class="toggle-label">启用 Alpha 抠图----仅限准许情况下使用----</div>
              <p class="toggle-hint">适合高难度场景，开启后可使用下方阈值调节。</p>
            </div>
            <label class="switch" aria-label="启用 Alpha 抠图">
              <input type="checkbox" id="alpha-matting-toggle" />
              <span class="switch-slider" aria-hidden="true"></span>
            </label>
          </div>
          <div class="toggle-row">
            <div class="toggle-text">
              <div class="toggle-label">遮罩后处理----默认开启以削减黑边----</div>
              <p class="toggle-hint">自动平滑遮罩边缘，弱化 1~3 像素的黑边，可按需关闭。</p>
            </div>
            <label class="switch" aria-label="遮罩后处理">
              <input type="checkbox" id="post-process-toggle" checked />
              <span class="switch-slider" aria-hidden="true"></span>
            </label>
          </div>
        </div>

        <div class="control-panel__body">
          <div class="slider-control" id="slider-foreground">
            <div class="slider-label">
              <span>前景阈值</span>
              <span class="slider-value" id="alpha-foreground-value">240</span>
            </div>
            <input
              type="range"
              id="alpha-foreground"
              min="0"
              max="255"
              value="240"
            />
            <p class="slider-hint">数值越高越倾向保留主体亮部，处理复杂发丝时可适当上调。</p>
          </div>
          <div class="slider-control" id="slider-background">
            <div class="slider-label">
              <span>背景阈值</span>
              <span class="slider-value" id="alpha-background-value">20</span>
            </div>
            <input
              type="range"
              id="alpha-background"
              min="0"
              max="255"
              value="20"
            />
            <p class="slider-hint">默认 20 可削弱黑边，减小该值会压制背景噪点，调节时请留意主体细节。</p>
          </div>
          <div class="slider-control" id="slider-erode">
            <div class="slider-label">
              <span>腐蚀尺寸</span>
              <span class="slider-value" id="alpha-erode-value">15</span>
            </div>
            <input
              type="range"
              id="alpha-erode"
              min="0"
              max="255"
              value="15"
            />
            <p class="slider-hint">用于平滑遮罩边界，小图建议保持 10~20，过大可能吞掉细节。</p>
          </div>
        </div>
      </section>

      <div class="model-selector" id="model-selector">
        <span>当前模型：<span class="current-model-label" id="current-model-label"></span></span>
        <button type="button" id="open-model-dialog">更换模型</button>
      </div>
    </header>

    <label class="drop-area" id="drop-area" for="file-input">
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path
          d="M12 2a6 6 0 0 0-5.996 6.291A4.5 4.5 0 0 0 6.5 20h11a4.5 4.5 0 0 0 1.447-8.776A6.002 6.002 0 0 0 12 2Zm0 2a4 4 0 0 1 3.796 5.349 1 1 0 0 0 .665 1.297A2.5 2.5 0 0 1 17.5 18h-11a2.5 2.5 0 0 1-.619-4.922 1 1 0 0 0 .644-1.31A4 4 0 0 1 12 4Zm0 4a1 1 0 0 0-1 1v3H9l3 4 3-4h-2V9a1 1 0 0 0-1-1Z"
        />
      </svg>
      <div class="hint">拖拽或点击选择图片</div>
      <div class="tip">支持 JPG、PNG、WebP 等常见格式，批量处理自动下载</div>
      <input id="file-input" type="file" accept="image/*" multiple />
    </label>

    <section class="task-list" id="task-list"></section>

    <footer>!!仅限公司内部使用!!</footer>

    <div class="model-dialog" id="model-dialog" role="dialog" aria-modal="true">
      <div class="model-dialog__card">
        <div class="model-dialog__header">
          <h2>选择抠图模型</h2>
          <p class="subtitle">
            不同模型侧重的场景不同，悬停可查看简介，确认后将作用于后续任务。
          </p>
        </div>
        <div class="model-dialog__body">
          <div class="model-grid" id="model-grid"></div>
        </div>
        <div class="model-dialog__actions">
          <button type="button" class="cancel-btn" id="cancel-model">取消</button>
          <button type="button" class="confirm-btn" id="confirm-model">确定</button>
        </div>
      </div>
    </div>

    <script>
      // 自定义接口地址，可根据需要修改。
      const API_BASE = "http://192.168.1.5:7000/api";
      const ENDPOINT = API_BASE.replace(/\/$/, "") + "/remove";

      const DEFAULT_MODEL = "bria-rmbg";

      const MODELS = [
        {
          id: "bria-rmbg",
          name: "BRIA RMBG v2（默认）",
          description: "来自 BRIA 的商业模型，电商与商品抠图表现稳定。",
        },
        {
          id: "u2net",
          name: "U²-Net 通用-快但扣不太好",
          description: "适用多种主体抠图场景，平衡速度与质量。",
        },
        {
          id: "isnet-general-use",
          name: "IS-Net 通用-快，扣的一般",
          description: "IS-Net 官方权重，兼顾速度与准确率。",
        },
       // {
       //   id: "isnet-anime",
       //   name: "IS-Net 动漫",
       //   description: "面向二次元/插画主体，边缘干净不毛刺。",
       // },
       // {
       //   id: "dis_custom",
       //   name: "DIS 自定义",
       //   description: "兼容自训练 DIS 模型（需在服务器提供 model_path）。",
       // },
       // {
       //   id: "ben_custom",
       //   name: "Background Eraser 自定义",
       //   description: "适配 BEN/BG Eraser 系列自定义权重。",
       // },
        {
          id: "sam",
          name: "Segment Anything (SAM)-极快，扣的非常不行",
          description: "支持 SAM 编解码流程，可配合 extras 指定提示点。",
        },
        {
          id: "silueta",
          name: "Silueta-调用使用",
          description: "轻量抠图网络，适合部署在资源受限环境。",
        },
      ];

      const AVAILABLE_MODEL_IDS = new Set(MODELS.map((item) => item.id));

      const dropArea = document.getElementById("drop-area");
      const fileInput = document.getElementById("file-input");
      const taskList = document.getElementById("task-list");
      const modelDialog = document.getElementById("model-dialog");
      const modelGrid = document.getElementById("model-grid");
      const openModelDialog = document.getElementById("open-model-dialog");
      const cancelModel = document.getElementById("cancel-model");
      const confirmModel = document.getElementById("confirm-model");
      const currentModelLabel = document.getElementById("current-model-label");
      const alphaMattingToggle = document.getElementById("alpha-matting-toggle");
      const advancedGuard = document.getElementById("advanced-guard");
      const advancedControlPanel = document.getElementById("advanced-control-panel");
      const advancedPasswordInput = document.getElementById("advanced-password");
      const unlockAdvancedButton = document.getElementById("unlock-advanced");
      const advancedFeedback = document.getElementById("advanced-feedback");
      const postProcessToggle = document.getElementById("post-process-toggle");
      const sliderDefinitions = [
        {
          stateKey: "alphaMattingForegroundThreshold",
          slider: document.getElementById("alpha-foreground"),
          valueEl: document.getElementById("alpha-foreground-value"),
        },
        {
          stateKey: "alphaMattingBackgroundThreshold",
          slider: document.getElementById("alpha-background"),
          valueEl: document.getElementById("alpha-background-value"),
        },
        {
          stateKey: "alphaMattingErodeSize",
          slider: document.getElementById("alpha-erode"),
          valueEl: document.getElementById("alpha-erode-value"),
        },
      ];

      const sliderMap = Object.fromEntries(
        sliderDefinitions
          .filter((config) => config.slider && config.valueEl)
          .map((config) => [config.stateKey, config])
      );

      const MIN_ALPHA_THRESHOLD_GAP = 5;

      function blobToDataUrl(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.addEventListener("load", () => {
            resolve(typeof reader.result === "string" ? reader.result : "");
          });
          reader.addEventListener("error", () => {
            reject(reader.error || new Error("读取图像数据失败"));
          });
          try {
            reader.readAsDataURL(blob);
          } catch (error) {
            reject(error);
          }
        });
      }

      function loadImageFromDataUrl(dataUrl) {
        return new Promise((resolve, reject) => {
          if (!dataUrl) {
            reject(new Error("缺少图像数据"));
            return;
          }
          const image = new Image();
          image.decoding = "async";
          image.addEventListener("load", () => {
            resolve(image);
          });
          image.addEventListener("error", () => {
            reject(new Error("无法加载图像数据"));
          });
          image.src = dataUrl;
        });
      }

      function softenAlphaEdges(imageData) {
        if (!imageData) {
          return;
        }

        const { data, width, height } = imageData;
        if (!data || !width || !height) {
          return;
        }

        const totalPixels = width * height;
        const originalAlpha = new Uint8ClampedArray(totalPixels);

        for (let i = 0; i < totalPixels; i += 1) {
          originalAlpha[i] = data[i * 4 + 3];
        }

        const kernel = [
          [1, 2, 1],
          [2, 4, 2],
          [1, 2, 1],
        ];

        for (let y = 0; y < height; y += 1) {
          for (let x = 0; x < width; x += 1) {
            const index = y * width + x;
            const baseAlpha = originalAlpha[index];

            if (baseAlpha === 0) {
              data[index * 4] = 0;
              data[index * 4 + 1] = 0;
              data[index * 4 + 2] = 0;
              data[index * 4 + 3] = 0;
              continue;
            }

            if (baseAlpha === 255) {
              data[index * 4 + 3] = 255;
              continue;
            }

            let weightedSum = 0;
            let weightTotal = 0;

            for (let ky = -1; ky <= 1; ky += 1) {
              const ny = y + ky;
              if (ny < 0 || ny >= height) {
                continue;
              }
              const row = kernel[ky + 1];

              for (let kx = -1; kx <= 1; kx += 1) {
                const nx = x + kx;
                if (nx < 0 || nx >= width) {
                  continue;
                }
                const weight = row[kx + 1];
                weightedSum += weight * originalAlpha[ny * width + nx];
                weightTotal += weight;
              }
            }

            if (weightTotal === 0) {
              continue;
            }

            const averaged = Math.round(weightedSum / weightTotal);
            const finalAlpha = Math.max(
              0,
              Math.min(255, Math.round((averaged + baseAlpha) / 2))
            );

            const originalAlphaNorm = baseAlpha / 255;
            const finalAlphaNorm = finalAlpha / 255;

            data[index * 4 + 3] = finalAlpha;

            if (finalAlpha === 0) {
              data[index * 4] = 0;
              data[index * 4 + 1] = 0;
              data[index * 4 + 2] = 0;
            } else if (originalAlphaNorm > 0) {
              const ratio = finalAlphaNorm / originalAlphaNorm;
              data[index * 4] = Math.max(
                0,
                Math.min(255, Math.round(data[index * 4] * ratio))
              );
              data[index * 4 + 1] = Math.max(
                0,
                Math.min(255, Math.round(data[index * 4 + 1] * ratio))
              );
              data[index * 4 + 2] = Math.max(
                0,
                Math.min(255, Math.round(data[index * 4 + 2] * ratio))
              );
            }
          }
        }
      }

      async function smoothTransparentPngBlob(blob) {
        let baseDataUrl = "";
        try {
          baseDataUrl = await blobToDataUrl(blob);
        } catch (error) {
          console.warn("读取透明 PNG 数据失败", error);
        }

        try {
          if (!baseDataUrl) {
            throw new Error("缺少 PNG 数据 URL");
          }

          const image = await loadImageFromDataUrl(baseDataUrl);
          const width = Math.max(image.naturalWidth || image.width || 0, 1);
          const height = Math.max(image.naturalHeight || image.height || 0, 1);

          let canvas;
          if (typeof OffscreenCanvas !== "undefined") {
            canvas = new OffscreenCanvas(width, height);
          } else {
            canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
          }

          const context = canvas.getContext("2d", { willReadFrequently: true });
          if (!context) {
            throw new Error("无法创建画布上下文");
          }

          context.imageSmoothingEnabled = true;
          context.imageSmoothingQuality = "high";
          context.clearRect(0, 0, width, height);
          context.drawImage(image, 0, 0, width, height);

          const imageData = context.getImageData(0, 0, width, height);
          softenAlphaEdges(imageData);
          context.putImageData(imageData, 0, 0);

          const outputBlob = canvas.convertToBlob
            ? await canvas.convertToBlob({ type: "image/png" })
            : await new Promise((resolve, reject) => {
                canvas.toBlob((result) => {
                  if (result) {
                    resolve(result);
                  } else {
                    reject(new Error("PNG 导出失败"));
                  }
                }, "image/png");
              });

          let dataUrl = baseDataUrl;
          try {
            dataUrl = await blobToDataUrl(outputBlob);
          } catch (error) {
            console.warn("转换平滑结果为 DataURL 失败，使用原始数据", error);
          }

          return { blob: outputBlob, dataUrl };
        } catch (error) {
          if (baseDataUrl) {
            return { blob, dataUrl: baseDataUrl };
          }
          return { blob, dataUrl: "" };
        }
      }

      function createWhiteBackgroundJpeg(sourceDataUrl, quality = 0.92) {
        return new Promise((resolve, reject) => {
          const image = new Image();
          image.decoding = "async";
          image.addEventListener("load", () => {
            try {
              const width = Math.max(image.naturalWidth || image.width || 0, 1);
              const height = Math.max(image.naturalHeight || image.height || 0, 1);
              const canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              const context = canvas.getContext("2d");
              if (!context) {
                reject(new Error("无法创建画布上下文"));
                return;
              }
              context.fillStyle = "#ffffff";
              context.fillRect(0, 0, width, height);
              context.drawImage(image, 0, 0, width, height);
              canvas.toBlob(
                (jpegBlob) => {
                  if (!jpegBlob) {
                    reject(new Error("JPEG 转换失败"));
                    return;
                  }
                  const url = URL.createObjectURL(jpegBlob);
                  resolve({ blob: jpegBlob, url });
                },
                "image/jpeg",
                quality
              );
            } catch (canvasError) {
              reject(canvasError);
            }
          });
          image.addEventListener("error", () => {
            reject(new Error("无法加载生成的 PNG 数据"));
          });
          image.src = sourceDataUrl;
        });
      }

      async function prepareResultVariants(blob, originalName) {
        const safeBaseName =
          originalName && /[^.]/.test(originalName)
            ? originalName.replace(/\.[^.]+$/, "")
            : "output";

        let workingBlob = blob;
        let pngDataUrl = "";

        try {
          const enhanced = await smoothTransparentPngBlob(blob);
          if (enhanced?.blob) {
            workingBlob = enhanced.blob;
          }
          if (enhanced?.dataUrl) {
            pngDataUrl = enhanced.dataUrl;
          }
        } catch (error) {
          console.warn("平滑透明遮罩失败，使用原始结果", error);
        }

        if (!pngDataUrl) {
          try {
            pngDataUrl = await blobToDataUrl(workingBlob);
          } catch (error) {
            console.warn("生成透明 PNG 数据失败", error);
          }
        }

        const pngUrl = URL.createObjectURL(workingBlob);
        const variants = {
          png: {
            blob: workingBlob,
            url: pngUrl,
            downloadName: `${safeBaseName}-removed.png`,
            previewUrl: pngDataUrl || pngUrl,
            label: "PNG 透明",
          },
        };

        if (pngDataUrl) {
          try {
            const jpegResult = await createWhiteBackgroundJpeg(pngDataUrl);
            variants.jpg = {
              blob: jpegResult.blob,
              url: jpegResult.url,
              downloadName: `${safeBaseName}-white.jpg`,
              previewUrl: jpegResult.url,
              label: "JPG 白底",
            };
          } catch (error) {
            console.warn("生成 JPG 白底失败", error);
          }
        }

        return variants;
      }

      const controlState = {
        alphaMatting: Boolean(alphaMattingToggle?.checked),
        alphaMattingForegroundThreshold: 240,
        alphaMattingBackgroundThreshold: 20,
        alphaMattingErodeSize: 15,
        postProcessMask: Boolean(postProcessToggle?.checked),
      };

      function unlockAdvancedPanel() {
        if (!advancedPasswordInput || !advancedControlPanel || !advancedGuard) {
          return;
        }

        const password = advancedPasswordInput.value.trim();
        if (password === "2008") {
          advancedControlPanel.classList.remove("hidden");
          advancedControlPanel.setAttribute("aria-hidden", "false");
          advancedGuard.classList.add("hidden");
          advancedPasswordInput.value = "";
          if (advancedFeedback) {
            advancedFeedback.textContent = "";
          }
        } else {
          if (advancedFeedback) {
            advancedFeedback.textContent = "口令错误，禁止开启。";
          }
          advancedPasswordInput.focus();
        }
      }

      if (unlockAdvancedButton) {
        unlockAdvancedButton.addEventListener("click", unlockAdvancedPanel);
      }

      if (advancedPasswordInput) {
        advancedPasswordInput.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            event.preventDefault();
            unlockAdvancedPanel();
          }
        });
      }

      function updateSliderDisplay(config, value) {
        if (!config?.slider || !config?.valueEl) {
          return;
        }
        config.slider.value = String(value);
        config.valueEl.textContent = String(value);
      }

      function enforceAlphaThresholdRelationship(changedKey) {
        const fgConfig = sliderMap.alphaMattingForegroundThreshold;
        const bgConfig = sliderMap.alphaMattingBackgroundThreshold;
        if (!fgConfig || !bgConfig) {
          return;
        }

        let foreground = controlState.alphaMattingForegroundThreshold;
        let background = controlState.alphaMattingBackgroundThreshold;

        if (foreground < 0 || foreground > 255) {
          foreground = Math.min(Math.max(foreground, 0), 255);
        }
        if (background < 0 || background > 255) {
          background = Math.min(Math.max(background, 0), 255);
        }

        const gap = foreground - background;
        if (gap >= MIN_ALPHA_THRESHOLD_GAP) {
          updateSliderDisplay(fgConfig, foreground);
          updateSliderDisplay(bgConfig, background);
          controlState.alphaMattingForegroundThreshold = foreground;
          controlState.alphaMattingBackgroundThreshold = background;
          return;
        }

        if (changedKey === "alphaMattingForegroundThreshold") {
          foreground = Math.min(
            255,
            Math.max(background + MIN_ALPHA_THRESHOLD_GAP, foreground)
          );
        } else if (changedKey === "alphaMattingBackgroundThreshold") {
          background = Math.max(
            0,
            Math.min(foreground - MIN_ALPHA_THRESHOLD_GAP, background)
          );
        }

        if (foreground - background < MIN_ALPHA_THRESHOLD_GAP) {
          if (changedKey === "alphaMattingForegroundThreshold") {
            background = Math.max(0, foreground - MIN_ALPHA_THRESHOLD_GAP);
          } else {
            foreground = Math.min(255, background + MIN_ALPHA_THRESHOLD_GAP);
          }
        }

        controlState.alphaMattingForegroundThreshold = foreground;
        controlState.alphaMattingBackgroundThreshold = background;
        updateSliderDisplay(fgConfig, foreground);
        updateSliderDisplay(bgConfig, background);
      }

      sliderDefinitions.forEach((config) => {
        if (!config.slider || !config.valueEl) {
          return;
        }

        const container = config.slider.closest(".slider-control");
        config.container = container;

        const value = Number(config.slider.value);
        controlState[config.stateKey] = value;
        config.valueEl.textContent = String(value);

        config.slider.addEventListener("input", (event) => {
          const target = event.target;
          if (!(target instanceof HTMLInputElement)) {
            return;
          }
          const newValue = Number(target.value);
          controlState[config.stateKey] = newValue;
          config.valueEl.textContent = String(newValue);
          if (
            config.stateKey === "alphaMattingForegroundThreshold" ||
            config.stateKey === "alphaMattingBackgroundThreshold"
          ) {
            enforceAlphaThresholdRelationship(config.stateKey);
          }
        });
      });

      enforceAlphaThresholdRelationship("alphaMattingForegroundThreshold");

      function updateAlphaMattingUI() {
        sliderDefinitions.forEach((config) => {
          config.container?.classList.toggle(
            "inactive",
            !controlState.alphaMatting
          );
        });
      }

      if (alphaMattingToggle) {
        controlState.alphaMatting = alphaMattingToggle.checked;
        alphaMattingToggle.addEventListener("change", () => {
          controlState.alphaMatting = alphaMattingToggle.checked;
          updateAlphaMattingUI();
        });
      }

      if (postProcessToggle) {
        controlState.postProcessMask = postProcessToggle.checked;
        postProcessToggle.addEventListener("change", () => {
          controlState.postProcessMask = postProcessToggle.checked;
        });
      }

      updateAlphaMattingUI();

      let selectedModel = AVAILABLE_MODEL_IDS.has(DEFAULT_MODEL)
        ? DEFAULT_MODEL
        : MODELS[0]?.id || DEFAULT_MODEL;
      let pendingModel = selectedModel;

      function updateCurrentModelLabel() {
        const model = MODELS.find((item) => item.id === selectedModel);
        if (!model && MODELS.length) {
          selectedModel = MODELS[0].id;
          currentModelLabel.textContent = MODELS[0].name;
          return;
        }
        currentModelLabel.textContent = model ? model.name : selectedModel;
      }

      function renderModelOptions() {
        modelGrid.innerHTML = "";
        MODELS.forEach((model) => {
          const card = document.createElement("button");
          card.type = "button";
          card.className = "model-card";
          card.dataset.modelId = model.id;
          card.dataset.selected = model.id === pendingModel;
          card.setAttribute("aria-pressed", model.id === pendingModel ? "true" : "false");

          const title = document.createElement("div");
          title.className = "model-card__name";
          title.textContent = model.name;

          const desc = document.createElement("div");
          desc.className = "model-card__desc";
          desc.textContent = model.description;

          const tooltip = document.createElement("div");
          tooltip.className = "model-card__tooltip";
          tooltip.textContent = model.description;

          card.appendChild(title);
          card.appendChild(desc);
          card.appendChild(tooltip);

          card.addEventListener("click", () => {
            pendingModel = model.id;
            [...modelGrid.children].forEach((child) => {
              const isSelected = child.dataset.modelId === pendingModel;
              child.dataset.selected = isSelected;
              child.setAttribute("aria-pressed", isSelected ? "true" : "false");
            });
          });

          modelGrid.appendChild(card);
        });
      }

      function openModelSelector() {
        pendingModel = selectedModel;
        renderModelOptions();
        modelDialog.classList.add("visible");
      }

      function closeModelSelector() {
        modelDialog.classList.remove("visible");
      }

      openModelDialog.addEventListener("click", openModelSelector);
      cancelModel.addEventListener("click", closeModelSelector);
      confirmModel.addEventListener("click", () => {
        if (!AVAILABLE_MODEL_IDS.has(pendingModel) && MODELS.length) {
          pendingModel = MODELS[0].id;
        }
        selectedModel = pendingModel;
        updateCurrentModelLabel();
        closeModelSelector();
      });

      modelDialog.addEventListener("click", (event) => {
        if (event.target === modelDialog) {
          closeModelSelector();
        }
      });

      updateCurrentModelLabel();

      const preventDefaults = (event) => {
        event.preventDefault();
        event.stopPropagation();
      };

      ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        document.addEventListener(eventName, preventDefaults, false);
      });

      ["dragenter", "dragover"].forEach((eventName) => {
        document.addEventListener(
          eventName,
          () => dropArea.classList.add("dragover"),
          false
        );
      });

      ["dragleave", "drop"].forEach((eventName) => {
        document.addEventListener(
          eventName,
          (event) => {
            const related = event.relatedTarget;
            if (!(related instanceof Node) || !dropArea.contains(related)) {
              dropArea.classList.remove("dragover");
            }
          },
          false
        );
      });

      document.addEventListener("drop", (event) => {
        dropArea.classList.remove("dragover");
        const files = event.dataTransfer?.files;
        if (files && files.length) {
          handleFiles(files);
        }
      });

      document.addEventListener("paste", (event) => {
        const activeElement = document.activeElement;
        if (
          activeElement &&
          (activeElement instanceof HTMLInputElement ||
            activeElement instanceof HTMLTextAreaElement ||
            activeElement.isContentEditable)
        ) {
          return;
        }

        const clipboardData = event.clipboardData;
        if (!clipboardData) {
          return;
        }

        const images = [];
        for (const item of clipboardData.items || []) {
          if (item.kind !== "file") {
            continue;
          }
          const file = item.getAsFile();
          if (!file || !file.type.startsWith("image/")) {
            continue;
          }
          if (file.name) {
            images.push(file);
            continue;
          }
          try {
            const normalized = new File(
              [file],
              `pasted-image-${Date.now()}.png`,
              { type: file.type || "image/png" }
            );
            images.push(normalized);
          } catch (error) {
            images.push(file);
          }
        }

        if (images.length === 0) {
          return;
        }

        event.preventDefault();
        handleFiles(images);
      });

      dropArea.addEventListener("click", () => fileInput.click());
      fileInput.addEventListener("change", () => {
        if (fileInput.files?.length) {
          handleFiles(fileInput.files);
          fileInput.value = "";
        }
      });

      function handleFiles(fileList) {
        [...fileList].forEach((file) => {
          if (!file.type.startsWith("image/")) {
            const task = createTaskItem(file);
            handleError(task, "不支持的文件类型");
            return;
          }
          processFile(file);
        });
      }

      function ensureValidModelSelection() {
        if (!AVAILABLE_MODEL_IDS.has(selectedModel) && MODELS.length) {
          selectedModel = MODELS[0].id;
          updateCurrentModelLabel();
        }
      }

      function createTaskItem(file) {
        const item = document.createElement("article");
        item.className = "task-item";

        const header = document.createElement("div");
        header.className = "task-header";

        const name = document.createElement("div");
        name.className = "task-name";
        name.textContent = file.name;

        const status = document.createElement("div");
        status.className = "task-status";
        status.textContent = "等待上传";

        header.appendChild(name);
        header.appendChild(status);

        const progressBar = document.createElement("div");
        progressBar.className = "progress-bar";
        const progressFill = document.createElement("div");
        progressFill.className = "progress-fill";
        progressBar.appendChild(progressFill);

        const formatToggle = document.createElement("div");
        formatToggle.className = "format-toggle hidden";
        formatToggle.setAttribute("role", "group");
        formatToggle.setAttribute("aria-label", "下载格式切换");

        const jpgOption = document.createElement("button");
        jpgOption.type = "button";
        jpgOption.className = "format-toggle__option";
        jpgOption.dataset.format = "jpg";
        jpgOption.textContent = "JPG 白底";
        jpgOption.setAttribute("aria-pressed", "false");

        const pngOption = document.createElement("button");
        pngOption.type = "button";
        pngOption.className = "format-toggle__option";
        pngOption.dataset.format = "png";
        pngOption.textContent = "PNG 透明";
        pngOption.setAttribute("aria-pressed", "false");

        formatToggle.appendChild(jpgOption);
        formatToggle.appendChild(pngOption);

        const downloadLink = document.createElement("a");
        downloadLink.className = "download-link";
        downloadLink.textContent = "下载结果";
        downloadLink.href = "#";
        downloadLink.download = `${file.name.replace(/\.[^.]+$/, "")}-removed.png`;

        item.appendChild(header);
        item.appendChild(progressBar);
        item.appendChild(formatToggle);
        item.appendChild(downloadLink);

        taskList.prepend(item);

        const baseName = file.name.replace(/\.[^.]+$/, "") || "output";
        const formatButtons = { jpg: jpgOption, png: pngOption };
        let variants = null;
        let selectedFormat = "png";
        let isCompleted = false;

        const updateFormatButtonState = () => {
          Object.entries(formatButtons).forEach(([format, button]) => {
            const available = Boolean(variants?.[format]);
            button.disabled = !available;
            button.classList.toggle("format-toggle__option--unavailable", !available);
            button.setAttribute("aria-disabled", available ? "false" : "true");
            const isActive = available && format === selectedFormat;
            button.setAttribute("aria-pressed", isActive ? "true" : "false");
          });
        };

        const resolveActiveVariant = () => {
          if (!variants) {
            return null;
          }
          if (variants[selectedFormat]) {
            return variants[selectedFormat];
          }
          if (variants.png) {
            selectedFormat = "png";
            return variants.png;
          }
          if (variants.jpg) {
            selectedFormat = "jpg";
            return variants.jpg;
          }
          return null;
        };

        const updateDownloadLink = () => {
          const active = resolveActiveVariant();
          if (!active) {
            downloadLink.classList.remove("visible");
            return;
          }
          downloadLink.href = active.url;
          downloadLink.download = active.downloadName;
          downloadLink.textContent = `下载 ${active.label}`;
          downloadLink.classList.add("visible");
        };

        const refreshStatusIfCompleted = () => {
          if (!isCompleted) {
            return;
          }
          const active = resolveActiveVariant();
          if (active) {
            status.textContent = `已完成（${active.label}）`;
          }
        };

        const setSelectedFormat = (format) => {
          if (variants && !variants[format]) {
            updateFormatButtonState();
            updateDownloadLink();
            refreshStatusIfCompleted();
            return;
          }
          if (selectedFormat === format && variants?.[format]) {
            refreshStatusIfCompleted();
            return;
          }
          selectedFormat = format;
          updateFormatButtonState();
          updateDownloadLink();
          refreshStatusIfCompleted();
        };

        jpgOption.addEventListener("click", () => setSelectedFormat("jpg"));
        pngOption.addEventListener("click", () => setSelectedFormat("png"));

        downloadLink.addEventListener("click", (event) => {
          event.preventDefault();
          const active = resolveActiveVariant();
          if (active) {
            triggerDownload(active.blob, active.downloadName);
          }
        });

        const setVariants = (newVariants) => {
          variants = newVariants;
          formatToggle.classList.remove("hidden");
          if (variants.png) {
            selectedFormat = "png";
          } else if (variants.jpg) {
            selectedFormat = "jpg";
          }
          updateFormatButtonState();
          updateDownloadLink();
        };

        const markCompleted = () => {
          isCompleted = true;
          refreshStatusIfCompleted();
        };

        const autoDownload = () => {
          const active = resolveActiveVariant();
          if (active) {
            triggerDownload(active.blob, active.downloadName);
          }
        };

        return {
          item,
          status,
          progressFill,
          downloadLink,
          setVariants,
          autoDownload,
          markCompleted,
          getActiveVariant: resolveActiveVariant,
          setSelectedFormat,
        };
      }

      function updateProgress(progressFill, percent) {
        progressFill.style.width = `${percent}%`;
      }

      function processFile(file) {
        const task = createTaskItem(file);
        ensureValidModelSelection();
        const xhr = new XMLHttpRequest();
        const formData = new FormData();
        formData.append("file", file, file.name);
        formData.append("model", selectedModel);
        formData.append("a", String(controlState.alphaMatting));
        formData.append(
          "af",
          String(controlState.alphaMattingForegroundThreshold)
        );
        formData.append(
          "ab",
          String(controlState.alphaMattingBackgroundThreshold)
        );
        formData.append("ae", String(controlState.alphaMattingErodeSize));
        formData.append("ppm", String(controlState.postProcessMask));
        formData.append("om", "false");

        const modelConfig = MODELS.find((item) => item.id === selectedModel);
        let requestUrl;
        try {
          requestUrl = new URL(ENDPOINT);
        } catch (error) {
          requestUrl = new URL(ENDPOINT, window.location.href);
        }
        if (modelConfig?.extras) {
          requestUrl.searchParams.set("extras", JSON.stringify(modelConfig.extras));
        }

        xhr.open("POST", requestUrl.toString(), true);
        xhr.responseType = "blob";

        xhr.upload.addEventListener("progress", (event) => {
          if (event.lengthComputable) {
            const percent = Math.round((event.loaded / event.total) * 50);
            updateProgress(task.progressFill, percent);
            task.status.textContent = `上传中 ${percent}%`;
          }
        });

        xhr.upload.addEventListener("load", () => {
          updateProgress(task.progressFill, 50);
          task.status.textContent = "处理中...";
        });

        xhr.addEventListener("progress", (event) => {
          if (event.lengthComputable) {
            const percent = Math.round((event.loaded / event.total) * 50);
            const totalPercent = 50 + percent;
            updateProgress(task.progressFill, totalPercent);
            task.status.textContent = `下载中 ${totalPercent}%`;
          } else {
            task.status.textContent = "处理中...";
          }
        });

        xhr.addEventListener("load", () => {
          if (xhr.status >= 200 && xhr.status < 300) {
            const blob = xhr.response;
            prepareResultVariants(blob, file.name)
              .then((variants) => {
                task.setVariants(variants);
                const activeVariant = task.getActiveVariant();
                const label = activeVariant?.label || "结果";
                task.status.textContent = `处理完成，正在下载 ${label}`;
                task.autoDownload();
                setTimeout(() => {
                  const finalVariant = task.getActiveVariant();
                  task.status.textContent = finalVariant
                    ? `已完成（${finalVariant.label}）`
                    : "已完成";
                  updateProgress(task.progressFill, 100);
                  task.markCompleted();
                }, 200);
              })
              .catch((error) => {
                console.error("结果生成出现异常，回退为原始透明图", error);
                const fallbackUrl = URL.createObjectURL(blob);
                const fallbackName =
                  file.name && /[^.]/.test(file.name)
                    ? file.name.replace(/\.[^.]+$/, "")
                    : "output";
                task.setVariants({
                  png: {
                    blob,
                    url: fallbackUrl,
                    downloadName: `${fallbackName}-removed.png`,
                    previewUrl: fallbackUrl,
                    label: "PNG 透明",
                  },
                });
                const activeVariant = task.getActiveVariant();
                const label = activeVariant?.label || "结果";
                task.status.textContent = `处理完成，正在下载 ${label}`;
                task.autoDownload();
                setTimeout(() => {
                  const finalVariant = task.getActiveVariant();
                  task.status.textContent = finalVariant
                    ? `已完成（${finalVariant.label}）`
                    : "已完成";
                  updateProgress(task.progressFill, 100);
                  task.markCompleted();
                }, 200);
              });
          } else {
            extractErrorMessage(xhr).then((message) => {
              handleError(task, message);
            });
          }
        });

        xhr.addEventListener("error", () => {
          handleError(task, "网络异常，稍后再试");
        });

        xhr.addEventListener("abort", () => {
          handleError(task, "上传已取消");
        });

        task.status.textContent = "准备上传";
        xhr.send(formData);
      }

      function parseErrorPayload(text) {
        if (!text) {
          return "处理失败：服务器未返回错误详情";
        }

        let message = "";

        try {
          const data = JSON.parse(text);
          if (data?.detail) {
            if (Array.isArray(data.detail)) {
              const combined = data.detail
                .map((item) => {
                  if (typeof item === "string") {
                    return item;
                  }
                  if (item?.msg && item?.loc) {
                    return `${item.msg}（${item.loc.join(" → ")}）`;
                  }
                  if (item?.msg) {
                    return item.msg;
                  }
                  return JSON.stringify(item);
                })
                .join("；");
              if (combined) {
                message = combined;
              }
            } else if (typeof data.detail === "string") {
              message = data.detail;
            }
          }

          if (!message && typeof data?.message === "string") {
            message = data.message;
          }
        } catch (error) {
          // 不是 JSON，继续尝试返回原始文本。
        }

        if (!message) {
          message = text;
        }

        if (/match pattern/i.test(message) || /regex/i.test(message)) {
          return "选择的模型不受服务端支持，请刷新页面或检查服务端配置。";
        }

        return message;
      }

      function extractErrorMessage(xhr) {
        const fallback = `处理失败：${xhr.status || 0} ${
          xhr.statusText || ""
        }`.trim();

        if (xhr.response instanceof Blob) {
          if (xhr.response.size === 0) {
            return Promise.resolve(fallback);
          }

          return xhr.response
            .text()
            .then((text) => parseErrorPayload(text.trim()))
            .catch(() => fallback);
        }

        const responseText =
          typeof xhr.responseText === "string" ? xhr.responseText.trim() : "";
        if (responseText) {
          return Promise.resolve(parseErrorPayload(responseText));
        }

        return Promise.resolve(fallback);
      }

      function triggerDownload(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        requestAnimationFrame(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
        });
      }

      function handleError(task, message) {
        task.status.textContent = message;
        task.progressFill.style.background = "#ef4444";
        task.progressFill.style.width = "100%";
      }
    </script>
  </body>
</html>
